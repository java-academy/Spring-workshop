:authors: Kamil Jankowski, Michał Jędrzejkiewicz, Hubert Milczarek
:source-highlighter: rouge
= Spring Core + Boot + MVC - warsztaty

== Wprowadzenie teoretyczne

=== Spring

Spring jest narzędziem usprawniającym tworzenie aplikacji w języku Java. Autorem jest Rod Johnson - australijski informatyk i muzykolog - który w październiku 2002 roku, przedstawił pierwszą wersję biblioteki w swojej książce pod tytułem: __Expert One-on-One J2EE Design and Development__. Głównym celem Springa było wyeliminowanie w jak największym stopniu konfiguracji środowiska, tak aby programista mógł się skupić wyłącznie na budowaniu.

==== Odwrócenie zależności - IoC - Inversion of Control

Jedną z najważniejszych funkcjonalności Springa jest mechanizm odwrócenia zależności. W wielkim skrócie, jest to kontrola nad składowymi obiektami danego programu. W tradycyjnym modelu programowania, napisany przez osobę kod używa funkcji biblioteki przez co to program ma kontrolę nad konkretnym narzędziem. Wykorzystując odwrócenie zależności, to biblioteka kieruje przepływem programu. Najważniejszymi zaletami są:

* oddzielenie implementacji od wykonywanego zadania
* uproszczona zmiana implementacji
* lepsza modularność - tworzenie małych niezależnych od siebie funkcjonalności
* łatwiejsze testowanie

==== Wstrzykiwanie zależności

Wstrzykiwanie zależności jest to jedna z możliwych implementacji odwrócenia zależności. W wielkim skrócie to wzorzec projektowy mający na celu automatyczne umieszczanie obiektów do klas np. za pomocą konstruktora.

==== Kontekst aplikacji - Application Context / Spring IoC Container

Aby móc wstrzykiwać obiekty do klas, należy je gdzieś utworzyć i mieć do nich dostęp. Z pomocą przychodzi __Spring IoC Container__, który jest popularnie wykorzysywany w implementacjach odwrócenia zależności. W springu nazywany jest również kontekstem aplikacji (ang. __Application Context__).

==== Ziarno - Bean
Pojedynczy element __Spring IoC Container__ nazywamy ziarnem (ang. __bean__). Ziarna możemy konfigurować poprzez pliki XML lub bezpośrednio w kodzie Javy. Poniższe dwa przykłady obrazują oba wymienione sposoby.

[source,xml]
.Przykład konfiguracji XML
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">

    <bean id="restTemplate" class="org.springframework.web.client.RestTemplate"/>
</beans>
----

==== Podstawowe adnotacje zwiazane ze wstrzykiwaniem zależności
W Springu możemy tworzyć i wstrzykiwać obiekty posługując się następującymi adnotacjami:

* `@Bean` - używane na metodach. Tworzy ziarno za pomocą oznaczonej metody.
* `@Autowired` - używana na metodach, polach lub konstruktorach. Informuje, że w tym miejscu powinny zostać wstrzyknięte zależności.
* `@Component` - używane na klasie. Aby skorzystać z mechanizmu wstrzykiwania, należy oznaczyć klasę która ma korzystać z niego.
* `@Configuration` - używane na klasie. Oznacza klasę, która definiuje ziarna.

[source,java]
.Stworzenie ziarna poprzez użycie Javy i Springa
----
package com.ships;

@Configuration
class AppConfig {
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
----

[source,java]
.Użycie ziarna w kodzie poprzez wstrzykniecie w konstruktor
----
package com.ships;

@Component
class ServiceConnector {

    private final RestTemplate restTemplate;

    @Autowired
    ServiceConnector(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }
}
----

=== Spring Boot

Minusem springa jest skomplikowana konfiguracja do uruchomienia aplikacji. Na rynku pojawiały sie coraz to nowe technologie zawierające w sobie wstrzykiwanie zależności. Wten programiści zaczęli pytać: "Po co nam spring skoro są inne przyjemniejsze i gotowe narzędzia?". Spring musiał sprostać wymaganiom aktualnego rynku i stworzył Spring Boot, bibliotekę która wymaga jedynie minimalnych ustawień Springa aby uruchomić aplikację. Oprócz tego oferuje:

* Wbudowany Tomcat, Jetty czy Undertow
* Automatycznie konfiguruje Springa oraz inne biblioteki (o ile jest to możliwe)
* Oferuje przydatne funkcje takie jak: metryki czy monitor kondycji
* Zrezygnowanie z konfiguracji oraz generacji kodu z XMLa
* Posiada przydatne wtyczki związane z bazami danych w pamięci
* Mniejsza ilość kodu aby osiągnąć tą samą funkcjonalność w Springu

Klasa startowa wygląda następująco:

[source,java]
.Użycie ziarna w kodzie poprzez wstrzykniecie w konstruktor
----
package com.ships;

@SpringBootApplication
class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}
----

==== Adnotacja @SpringBootApplication

`@SpringBootApplication` jest połączeniem trzech adnotacji:

* `@EnableAutoConfiguration` - uruchamia automatyczną konfigurację Spring Boot. Oznacza to, że Spring Boot konfiguruje dodane zależności do projektu. Przykładowo jeśli w projekcie znajduje się `HSQLDB`, ale nie ma ręcznie skonfgurowanych ziaren odpowiedzialnych za połączenie do bazy danych, biblioteka zrobi to automatycznie.
* `@ComponentScan` - skanuje pakiety w poszukiwaniu ziaren.
* `@Configuration`

==== SpringApplication.run()

Metoda `SpringApplication.run()` przygotowuje program do startu, między innymi:

* Uruchamia autonomiczną aplikację Spring Boot
* Rejestruje parametry wejściowe aplikacji
* Buduje instancje kontekstu aplikacji
* Tworzy instancje ziaren i dodaje je do kontenera



=== Spring MVC
:source-language: java

Jest to część framwerku odpowiadająca za tworzenie REST API.
Za pomocą adnotacji tworzy kontrelery RESTful.

Spring MVC używa programu Tomcat do obsługi żądań HTTP.
Otrzymane żądania są następnie mapowane do odpowiednich metod Spring MVC.

Spring MVC Używa Jacksona do mapowania obiektów do języka JSON i odwrotnie, jeśli używamy tego formatu do komunikacji.
Jednak jest on używany niejawnie.


==== Ogólne adnotacje

. `@RestController`  - służy do oznaczenia klasy mającej metody do obsługi rządań
. `@RequestMapping` - adnotacja do oznaczania metod które odpowiadają za obsługę danych żądań np

W przypadku gdy chcemy określić URI wszystkich metod w klasie
----
@RestController
@RequestMapping("/some/path", produces = <format of the output>)
class SomeController{
    ...
}
----
Gdy chcemy użyć mapowania na konkrtenj metodzie
----
@RequestMapping(value = "/some/path", method = RequestMethod.GET)
String getMethod(){
    ...
}
----
==== Adnotacje metod mapowanych na żądania REST

`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` itd. - metody do określania mapowań na żądania REST.
Równoważne z `@RequestMapping` z parametrem `method`.

* adnotacje te przyjmuję jako argument URI/ścieżkę danego żądania.
* Jako argumenty metod możemy oznaczyć część URI, jak pokazane poniżej, używając adnotacji `@PathVariable`.
* Jako argumenty możemy też przyjąć dodatkowe parametry w formacie json przesłane w ciele żądania, oznaczone adnotacją `@RequestBody`.
----
@GetMapping("some/path/{argument}")
ResposneEntity<String> geteMthod(@PathVariable String argument){
    ...
}

@PostMapping("some/path")
ResponseEntity<SomeClass> postMethod(@RequestBody RequestBodyClass reuqestBodyArgument){
    ...
}
----
Metody mapowane na żądania REST mogą zwracać dowolny obiekt, o ile wszystkie jego pola mają gettery.
W innym przypadku, Jackson może nie zadziałać poprawnie.
Tak samo argument oznaczony `@ResponseBody` powinien być typu ze zdefiniowanymi setterami.

==== `ResponseEntity`

Jako odpowiedzi żadania możemy zwrócić dowolne obiekty obiekty.
Jednak wtedy nie jesteśmy w stanie ustawić kodu odpowiedzi HTTP.
Z pomocą przychodzi klasa `ResponseEntity<T>`. Jako argument `T` przyjmuje ona zwracany typ.
W konstruktorze tej klasy możemy ustawić odpowiedni nagłówek, zwracany obiekt oraz kod odpowiedzi.
Klasa ta niejako "opakowuje" zwracany obiekt.
Najczęściej zwracanym kodem odpowiedzi jest `HttpStatus.OK`.


== Część praktyczna

=== Zadanie 1. Tworzenie aplikacji Spring Boot
. Utwórzcie nowy projekt springowy wykorzystując https://start.spring.io[Spring Initializr]
. Nazwijcie projekt `spring_workshop`, żeby nazwa była zgodna z nazwą projektu na gitlabie.
Co do samej ścieżki pakietów, możecie ją nazwać dowolnie.
. Skopiujcie wygenerowane pliki do do pobranego https://gitlab.com/choooobert/Spring-workshop[repozytorium].
. Usuńcie niepotrzebne pliki związane z wrapperem mavena (w projekcie nie będziemy z nich korzystać).

=== Zadanie 2. Tworzenie prostego kontrolera
. Utwórzcie pakiet `ships` wewnątrz głównego pakietu projektu.
. Dodajcie klasę `WelcomeController`.
. Dodajcie w niej metodę która dla scieżki __"/"__ zwróci napis __"Welcome to ships backend"__.

=== Zadanie 3. Dodanie serwisu statków
. W pakiecie `ships`, dodajcie klasę `Ship` tak żeby korespondowała z tym co jest w `Angular-workshop`.
. Używając adnotacji projektu __Lombok__ sprawcie, aby obiekty klasy były niezmienialne po utworzeniu,
oraz żeby klasa miała gettery dla wszystkich swoich pól.
. Dodajcie klasę `ShipsService` a w niej:
  * odpowiednią strukturę do przechowywania statków,
  * metody do usuwania konkretnego statku, dodawania nowego statku (na podstawie nazwy statku), pobierania listy statków
    ** Metoda dodająca statek powinna generować jego `id`.
       Powinna także rzucić odpowiedni wyjątek, jeśli statek o podanen nazwei jest już w serwisie.
    ** Metoda usuwająca statek powinna rzucać wyjątkiem gdy chcemy usunąć statek którego nie ma `ShipService`.

=== Zadanie 4. Dodanie kontrolera statków
. Utwórzcie klasę `ShipsController`.
. Oznaczcie klasę jako kontroler REST-owy zwracający dane w formacie __JSON__.
. Używając wstrzykiwania zależnosci, dodajcie do niej instancję `ShipsService`.
. Utwórzcie niej metody obsługujące następujace żadania RESTowe:
  * **GET** __/ships__ zwraca listę statków
  * **POST** __/ships/{nazwa statku}__ dodaje nowy statek i generuje dla niego ID.
Jeżeli statek o danej nazwie już istnieje, Metoda zwraca odpowiedni kod błędu.
  * **DELETE** __/ships/{nazwa statku}__  która usunie dany staek z serwisu.
W przypadku gdy danego statku nie ma w serwisie, metoda powinna zwrócić odpowiedni kod błędu.

=== Zadanie 5. Synchronizacja backendu z frontendem
. W repo `Angular-workshop` usuncie `InMemoryDataService`
. Dodajcie odpowiedni URL do backendu.
. Sprawdźcie czy obsługa REST-ów we frontendzie jest zgodna z tym co przed chwilą napisaliście w `Spring-workshop`.
. Do klasy `ShipsController` dodajecie adnotacje `@CrossOrigin("http://localhost:4200")`, aby backend mógł przetwarzać żadania z tego adresu.

=== Zadanie 6*. Testy dla REST API backendu
. Używając `MockMvc` napiszcie testy dla metod obsługujących żadania REST-owe.